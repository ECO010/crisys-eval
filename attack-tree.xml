<?xml version="1.0" encoding="UTF-8" standalone="no"?><attack-tree><node><name>Checking Completion of Score Overview</name><children><node><name>Asset Test 001</name><children><node><name>CWE-843: Access of Resource Using Incompatible Type ('Type Confusion')</name></node><node><name>CWE-415: Double Free</name><children><node><name>***Potential Mitigation: Choose a language that provides automatic memory management.</name></node></children></node><node><name>CWE-208: Observable Timing Discrepancy</name><children><node><name>CAPEC-462: Cross-Domain Search Timing</name><children><node><name>***Potential Mitigation: Design: The victim's site could protect all potentially sensitive functionality (e.g. search functions) with cross site request forgery (CSRF) protection and not perform any work on behalf of forged requests</name></node><node><name>***Potential Mitigation: Design: The browser's security model could be fixed to not leak timing information for cross domain requests</name></node><node><name>Execution Flow Step-1: [Determine service to send cross domain requests to] The adversary first determines which service they will be sending the requests to</name></node><node><name>Execution Flow Step-2: [Send and time various cross domain requests] Adversaries will send a variety of cross domain requests to the target, timing the time it takes for the target to respond. Although they won't be able to read the response, the adversary can use the time to infer information about what the service did upon receiving the request.</name><children><node><name>Technique for step 2: Using a GET request, leverage the "img" tag in conjunction with "onload() / onerror()" javascript events to time a response</name></node><node><name>Technique for step 2: Using a POST request, leverage the "iframe" element and use the "onload()" event to time a response</name></node></children></node><node><name>Execution Flow Step-3: [Infer information from the response time] After obtaining reponse times to various requests, the adversary will compare these times and infer potentially sensitive information. An example of this could be asking a service to retrieve information and random usernames. If one request took longer to process, it is likely that a user with that username exists, which could be useful knowledge to an adversary.</name><children><node><name>Technique for step 3: Compare timing of different requests to infer potentially sensitive information about a target service</name></node></children></node></children></node><node><name>CAPEC-541: Application Fingerprinting</name></node><node><name>CAPEC-580: System Footprinting</name><children><node><name>***Potential Mitigation: Keep patches up to date by installing weekly or daily if possible.</name></node><node><name>***Potential Mitigation: Identify programs that may be used to acquire peripheral information and block them by using a software restriction policy or tools that restrict program execution by using a process allowlist.</name></node></children></node></children></node><node><name>CWE-835: Loop with Unreachable Exit Condition ('Infinite Loop')</name></node><node><name>CWE-330: Use of Insufficiently Random Values</name><children><node><name>***Potential Mitigation: Use a well-vetted algorithm that is currently considered to be strong by experts in the field, and select well-tested implementations with adequate length seeds.
                  In general, if a pseudo-random number generator is not advertised as being cryptographically secure, then it is probably a statistical PRNG and should not be used in security-sensitive contexts.
                  Pseudo-random number generators can produce predictable numbers if the generator is known and the seed can be guessed. A 256-bit seed is a good starting point for producing a "random enough" number.</name></node><node><name>CAPEC-112: Brute Force</name><children><node><name>***Potential Mitigation: Select a provably large secret space for selection of the secret. Provably large means that the procedure by which the secret is selected does not have artifacts that significantly reduce the size of the total secret space.</name></node><node><name>***Potential Mitigation: Use a secret space that is well known and with no known patterns that may reduce functional size.</name></node><node><name>***Potential Mitigation: Do not provide the means for an attacker to determine success independently. This forces the attacker to check their guesses against an external authority, which can slow the attack and warn the defender. This mitigation may not be possible if testing material must appear externally, such as with a transmitted cryptotext.</name></node><node><name>Execution Flow Step-1: [Determine secret testing procedure] Determine how a potential guess of the secret may be tested. This may be accomplished by comparing some manipulation of the secret to a known value, use of the secret to manipulate some known set of data and determining if the result displays specific characteristics (for example, turning cryptotext into plaintext), or by submitting the secret to some external authority and having the external authority respond as to whether the value was the correct secret. Ideally, the attacker will want to determine the correctness of their guess independently since involvement of an external authority is usually slower and can provide an indication to the defender that a brute-force attack is being attempted.</name><children><node><name>Technique for step 1: Determine if there is a way to parallelize the attack. Most brute force attacks can take advantage of parallel techniques by dividing the search space among available resources, thus dividing the average time to success by the number of resources available. If there is a single choke point, such as a need to check answers with an external authority, the attackers' position is significantly degraded.</name></node></children></node><node><name>Execution Flow Step-2: [Reduce search space] Find ways to reduce the secret space. The smaller the attacker can make the space they need to search for the secret value, the greater their chances for success. There are a great many ways in which the search space may be reduced.</name><children><node><name>Technique for step 2: If possible, determine how the secret was selected. If the secret was determined algorithmically (such as by a random number generator) the algorithm may have patterns or dependencies that reduce the size of the secret space. If the secret was created by a human, behavioral factors may, if not completely reduce the space, make some types of secrets more likely than others. (For example, humans may use the same secrets in multiple places or use secrets that look or sound familiar for ease of recall.)</name></node><node><name>Technique for step 2: If the secret was chosen algorithmically, cryptanalysis can be applied to the algorithm to discover patterns in this algorithm. (This is true even if the secret is not used in cryptography.) Periodicity, the need for seed values, or weaknesses in the generator all can result in a significantly smaller secret space.</name></node><node><name>Technique for step 2: If the secret was chosen by a person, social engineering and simple espionage can indicate patterns in their secret selection. If old secrets can be learned (and a target may feel they have little need to protect a secret that has been replaced) hints as to their selection preferences can be gleaned. These can include character substitutions a target employs, patterns in sources (dates, famous phrases, music lyrics, family members, etc.). Once these patterns have been determined, the initial efforts of a brute-force attack can focus on these areas.</name></node><node><name>Technique for step 2: Some algorithmic techniques for secret selection may leave indicators that can be tested for relatively easily and which could then be used to eliminate large areas of the search space for consideration. For example, it may be possible to determine that a secret does or does not start with a given character after a relatively small number of tests. Alternatively, it might be possible to discover the length of the secret relatively easily. These discoveries would significantly reduce the search space, thus increasing speed with which the attacker discovers the secret.</name></node></children></node><node><name>Execution Flow Step-3: [Expand victory conditions] It is sometimes possible to expand victory conditions. For example, the attacker might not need to know the exact secret but simply needs a value that produces the same result using a one-way function. While doing this does not reduce the size of the search space, the presence of multiple victory conditions does reduce the likely amount of time that the attacker will need to explore the space before finding a workable value.</name></node><node><name>Execution Flow Step-4: [Gather information so attack can be performed independently.] If possible, gather the necessary information so a successful search can be determined without consultation of an external authority. This can be accomplished by capturing cryptotext (if the goal is decoding the text) or the encrypted password dictionary (if the goal is learning passwords).</name></node></children></node><node><name>CAPEC-485: Signature Spoofing by Key Recreation</name><children><node><name>***Potential Mitigation: Ensure cryptographic elements have been sufficiently tested for weaknesses.</name></node></children></node><node><name>CAPEC-59: Session Credential Falsification through Prediction</name><children><node><name>***Potential Mitigation: Use a strong source of randomness to generate a session ID.</name></node><node><name>***Potential Mitigation: Use adequate length session IDs</name></node><node><name>***Potential Mitigation: Do not use information available to the user in order to generate session ID (e.g., time).</name></node><node><name>***Potential Mitigation: Ideas for creating random numbers are offered by Eastlake [RFC1750]</name></node><node><name>***Potential Mitigation: Encrypt the session ID if you expose it to the user. For instance session ID can be stored in a cookie in encrypted format.</name></node><node><name>Execution Flow Step-1: [Find Session IDs] The attacker interacts with the target host and finds that session IDs are used to authenticate users.</name><children><node><name>Technique for step 1: An attacker makes many anonymous connections and records the session IDs assigned.</name></node><node><name>Technique for step 1: An attacker makes authorized connections and records the session tokens or credentials issued.</name></node></children></node><node><name>Execution Flow Step-2: [Characterize IDs] The attacker studies the characteristics of the session ID (size, format, etc.). As a results the attacker finds that legitimate session IDs are predictable.</name><children><node><name>Technique for step 2: Cryptanalysis. The attacker uses cryptanalysis to determine if the session IDs contain any cryptographic protections.</name></node><node><name>Technique for step 2: Pattern tests. The attacker looks for patterns (odd/even, repetition, multiples, or other arithmetic relationships) between IDs</name></node><node><name>Technique for step 2: Comparison against time. The attacker plots or compares the issued IDs to the time they were issued to check for correlation.</name></node></children></node><node><name>Execution Flow Step-3: [Match issued IDs] The attacker brute forces different values of session ID and manages to predict a valid session ID.</name><children><node><name>Technique for step 3: The attacker models the session ID algorithm enough to produce a compatible session IDs, or just one match.</name></node></children></node><node><name>Execution Flow Step-4: [Use matched Session ID] The attacker uses the falsified session ID to access the target system.</name><children><node><name>Technique for step 4: The attacker loads the session ID into their web browser and browses to restricted data or functionality.</name></node><node><name>Technique for step 4: The attacker loads the session ID into their network communications and impersonates a legitimate user to gain access to data or functionality.</name></node></children></node></children></node></children></node><node><name>CWE-476: NULL Pointer Dereference</name><children><node><name>***Potential Mitigation: If all pointers that could have been modified are sanity-checked previous to use, nearly all NULL pointer dereferences can be prevented.</name></node></children></node></children></node></children></node></attack-tree>